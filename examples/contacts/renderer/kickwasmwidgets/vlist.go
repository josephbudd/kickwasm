package kickwasmwidgets

import (
	"math"
	"syscall/js"

	"github.com/josephbudd/kicknotjs"
)

// VList is vertical list of verbose buttons.
type VList struct {
	div                  js.Value
	max                  uint64
	onSizeFunc           func()
	onNoSizeFunc         func()
	needToInitializeFunc func(count, state uint64)
	needToPrependFunc    func(button js.Value, count, state uint64)
	needToAppendFunc     func(button js.Value, count, state uint64)
	idState              uint64
	notjs                *kicknotjs.NotJS

	hideFunc    func(js.Value)
	showFunc    func(js.Value)
	isShownFunc func(js.Value) bool

	adjusting     bool
	srcollTop     int
	lastScrollTop int
}

// NewVList constructs a new VList.
// Param div is the div containing the list.
//  If the div is not empty it will be emptied so don't bother putting anything in it.
//  div must have.
//   * a styled height ( See "github.com/josephbudd/kickwasmwidgets/css/vlist.css" )
//   * its children will only be p's  and buttons.
//   * child p's are the top and botton padding.
//   * child buttons are the verbose options.
// Param idState
//  is vlist vlist's unique id.
//  it must be generated by VListState.GetNextState().
//  it will be passed as param state being ored with StateInitialize in calls to needToInitializeFunc.
//  it will be passed as param state being ored with StatePrepend in calls to needToPrependFunc.
//  it will be passed as param state being ored with StateAppend in calls to needToAppendFunc.
// Param max is the maximum amount of options.
//   The list will never have more than max options to control memory usage.
// Param onSizeFunc
//  is called when there will be a size to the list.
// Param onNoSizeFunc
//  is called when there will be no size to the list.
// Param needToInitializeFunc
//  is called when the list needs initialized.
//  is passed the params(count, state)
//  is asynchronous and returns nothing
//  it is expected to propogate a call back to vlist.Build
// Param needToPrependFunc
//  is called when the list needs to prepend more records.
//  is passed the params (button, count, state)
//  is asynchronous and returns nothing
//  it is expected to propogate a call back to vlist.Build
// Param needToAppendFunc
//  is called when the list needs to append more records.
//  is passed the params (button, count, state)
//  is asynchronous and returns nothing
//  it is expected to propogate a call back to vlist.Build
// Param notjs is a pointer to kicknotjs.NotJS
// Param hideFunc is a func that will hide this div.
//  it will take one param, any js.Value.
// Param showFunc is a func that will show this div.
//  it will take one param, any js.Value.
// Param isShownFunc is a func that will return if this div is shown.VList
//  it takes one param, any js.Value and returns a bool.
func NewVList(div js.Value,
	idState uint64,
	max uint64,
	onSizeFunc func(),
	onNoSizeFunc func(),
	needToInitializeFunc func(count, state uint64),
	needToPrependFunc func(button js.Value, count, state uint64),
	needToAppendFunc func(button js.Value, count, state uint64),
	hideFunc func(js.Value),
	showFunc func(js.Value),
	isShownFunc func(js.Value) bool,
	notjs *kicknotjs.NotJS,
) *VList {
	vlist := &VList{
		div:                  div,
		max:                  max,
		onSizeFunc:           onSizeFunc,
		onNoSizeFunc:         onNoSizeFunc,
		needToInitializeFunc: needToInitializeFunc,
		needToPrependFunc:    needToPrependFunc,
		needToAppendFunc:     needToAppendFunc,
		idState:              idState,
		notjs:                notjs,
		hideFunc:             hideFunc,
		showFunc:             showFunc,
		isShownFunc:          isShownFunc,
	}
	// setup div
	notjs.RemoveChildNodes(div)
	// fix max
	if vlist.max%2 != 0 {
		vlist.max++
	}
	vlist.max /= 2
	// setup scrolling
	cb := notjs.RegisterCallBack(vlist.handleOnScroll)
	notjs.SetOnScroll(div, cb)

	return vlist
}

// Start starts the list initializing it with the first records.
func (vlist *VList) Start() {
	state := StateInitialize | vlist.idState
	vlist.needToInitializeFunc(vlist.max, state)
}

// Hide hides the vlist.
func (vlist *VList) Hide() {
	vlist.hideFunc(vlist.div)
}

// Show unshides the vlist.
func (vlist *VList) Show() {
	vlist.showFunc(vlist.div)
}

// Toggle toggles the vlist visibility.
func (vlist *VList) Toggle() {
	if vlist.isShownFunc(vlist.div) {
		vlist.hideFunc(vlist.div)
	} else {
		vlist.showFunc(vlist.div)
	}
}

// Build rebuilds the vlist in some way.
func (vlist *VList) Build(buttons []js.Value, state, recordCount uint64) {
	vlist.adjusting = true
	if recordCount == 0 {
		// the user has not added any records.
		vlist.clear()
		vlist.onNoSizeFunc()
		return
	}
	if len(buttons) == 0 {
		// nothing to add
		return
	}
	// there are buttons.
	vlist.onSizeFunc()
	// adjust the lists.
	if (state & StateAppend) == StateAppend {
		vlist.append(buttons)
		return
	}
	if (state & StatePrepend) == StatePrepend {
		vlist.prepend(buttons)
		return
	}
	// StateInitialize
	vlist.initialize(buttons)
}

// GetPageSize returns the list's page size.
func (vlist *VList) GetPageSize() uint64 {
	return vlist.max
}

// GetIDState returns the list's idState.
func (vlist *VList) GetIDState() uint64 {
	return vlist.idState
}

func (vlist *VList) initialize(buttons []js.Value) {
	vlist.clear()
	vlist.append(buttons)
}

func (vlist *VList) append(buttons []js.Value) {
	notjs := vlist.notjs
	l := uint64(len(buttons))
	if l > vlist.max {
		buttons = buttons[:vlist.max]
	}
	div := vlist.div
	children := notjs.ChildrenSlice(div)
	l = uint64(len(children) - 1)
	bottom := children[l]
	count := l - 1
	maxlen := vlist.max * 2
	rc := 1
	// append to the back end of the list.
	for _, button := range buttons {
		notjs.InsertChildBefore(div, button, bottom)
		if count == maxlen {
			// remove the top of the list.
			notjs.RemoveChild(div, children[rc])
			rc++
		} else {
			// total # of buttons increased.
			count++
		}
		//div.scrollTo(0, div.scrollTop + Sizer.height(button))
	}
}

func (vlist *VList) prepend(buttons []js.Value) {
	notjs := vlist.notjs
	lr := uint64(len(buttons))
	if lr > vlist.max {
		buttons = buttons[:vlist.max]
		lr = vlist.max
	}
	div := vlist.div
	children := notjs.ChildrenSlice(div)
	rc := uint64(len(children)) - 2
	count := rc
	maxlen := vlist.max * 2
	scrollTop := float64(notjs.GetScrollTop(div))
	// prepend to the front end of the list.
	top := children[1]
	for _, button := range buttons {
		notjs.InsertChildBefore(div, button, top)
		// remove the bottom of the list.
		if count == maxlen {
			notjs.RemoveChild(div, children[rc])
			rc--
		} else {
			// total # of buttons increased.
			count++
		}
	}
	buttonHt := float64(0)
	children = notjs.ChildrenSlice(div)
	if len(children) > 2 {
		buttonHt = notjs.OuterHeight(children[1])
	}
	scrollTo := scrollTop + (buttonHt * float64(lr))
	to := scrollTop + scrollTo
	vlist.notjs.ScrollTo(div, 0, int(math.Floor(to)))
}

func (vlist *VList) clear() {
	notjs := vlist.notjs
	div := vlist.div
	notjs.RemoveChildNodes(div)
	p := notjs.CreateElement("p")
	notjs.AppendChild(div, p)
	p = notjs.CreateElement("p")
	notjs.AppendChild(div, p)
}

func (vlist *VList) handleOnScroll(args []js.Value) {
	if vlist.adjusting {
		vlist.adjusting = false
		return
	}
	notjs := vlist.notjs
	event := args[0]
	div := notjs.GetEventTarget(event)
	lastScrollTop := float64(vlist.lastScrollTop)
	vlist.lastScrollTop = notjs.GetScrollTop(div)
	scrollTop := float64(vlist.lastScrollTop)
	children := notjs.ChildrenSlice(div)
	l := len(children)
	bottom := float64(0)
	paddingHt := float64(0)
	if l >= 2 {
		// the first and last children are the p which are the padding.
		paddingHt = notjs.OuterHeight(children[0])
		bottom += paddingHt * 2.0
	}
	if l > 2 {
		// there is more then just padding
		bottom += notjs.OuterHeight(children[1]) * float64(l-2)
	}
	bottom -= notjs.InnerHeight(div)
	if scrollTop < lastScrollTop {
		// scrolling up
		if scrollTop > paddingHt {
			// not at the top.
			return
		}
		// at the top
		if lastScrollTop > paddingHt {
			// did not just do vlist the time before.
			vlist.needToPrependFunc(
				children[1],
				vlist.max,
				StatePrepend|vlist.idState,
			)
		}
	} else {
		// scrolling down
		if scrollTop < bottom {
			// not at the bottom
			return
		}
		// at the bottom
		// xcrollTop == bottom
		if lastScrollTop != bottom {
			// first time at the bottom
			vlist.needToAppendFunc(
				children[len(children)-2],
				vlist.max,
				StateAppend|vlist.idState,
			)
		}
	}
}

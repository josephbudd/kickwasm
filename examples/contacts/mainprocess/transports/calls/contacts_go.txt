package calls

import (
	"fmt"
	"sort"

	"github.com/josephbudd/kick/examples/contacts/mainprocess/ports/records"
	"github.com/josephbudd/kick/examples/contacts/mainprocess/portsi/repoi"
	"github.com/josephbudd/lpc"
)

type getContactParams struct {
	ID    uint64 `json:"id"`
	State uint64 `json:"state"`
}

type getContactsPageParams struct {
	State      uint64 `json:"state"`
	PageSize   uint64 `json:"pageSize"`
	Index      uint64 `json:"index,omit-empty"`
	StateMatch string `json:"stateMatch,omit-empty"`
	CityMatch  string `json:"cityMatch,omit-empty"`
}

func updateContact(contactRepo repoi.ContactRepoI, params *updateContactParams, call lpc.CallRendererBackFunc, callErr lpc.CallRendererBackErrorFunc) {
	if err := contactRepo.UpdateContact(params.Record); err != nil {
		mess := fmt.Sprint("updateContact: contactRepo.UpdateContact(params.Record): ", err.Error())
		// i want to preserve state so I will use call instead of callErr
		txparams := struct {
			Error   bool                   `json:"error"`
			Message string                 `json:"message"`
			Record  *records.ContactRecord `json:"record"`
			State   uint64                 `json:"state"`
		}{
			Error:   true,
			Message: mess,
			Record:  nil,
			State:   params.State,
		}
		call(txparams)
		return
	}
	// params.Record may have been updated so pass it back.
	txparams := struct {
		Error  bool                   `json:"error"`
		Record *records.ContactRecord `json:"record"`
		State  uint64                 `json:"state"`
	}{
		Error:  false,
		Record: params.Record,
		State:  params.State,
	}
	// if this is a new record then its id will be updated.
	call(txparams)
}

func getContact(contactRepo repoi.ContactRepoI, params *getContactParams, call lpc.CallRendererBackFunc, callErr lpc.CallRendererBackErrorFunc) {
	record, err := contactRepo.GetContact(params.ID)
	if err != nil {
		mess := fmt.Sprint("getContact: contactRepo.GetContact(id): ", err.Error())
		callErr(mess)
	}
	if record == nil {
		mess := fmt.Sprintf("getContact: contactRepo.GetContact(id): record not found for %d", params.ID)
		// i want to preserve state so I will use call instead of callErr
		txparams := struct {
			Error   bool                   `json:"error"`
			Message string                 `json:"message"`
			Record  *records.ContactRecord `json:"record"`
			State   uint64                 `json:"state"`
		}{
			Error:   true,
			Message: mess,
			Record:  nil,
			State:   params.State,
		}
		call(txparams)
	}
	txparams := struct {
		Error  bool                   `json:"error"`
		Record *records.ContactRecord `json:"record"`
		State  uint64                 `json:"state"`
	}{
		Error:  false,
		Record: record,
		State:  params.State,
	}
	call(txparams)
}

func getContacts(contactRepo repoi.ContactRepoI, call lpc.CallRendererBackFunc, callErr lpc.CallRendererBackErrorFunc) {
	rr, err := contactRepo.GetContacts()
	if err != nil {
		mess := fmt.Sprint("getContacts: contactRepo.GetContacts(): ", err.Error())
		callErr(mess)
	}
	txparams := struct {
		Error   bool                     `json:"error"`
		Records []*records.ContactRecord `json:"records"`
	}{
		Error:   false,
		Records: rr,
	}
	call(txparams)
}

func removeContact(contactRepo repoi.ContactRepoI, id uint64, call lpc.CallRendererBackFunc, callErr lpc.CallRendererBackErrorFunc) {
	err := contactRepo.RemoveContact(id)
	if err != nil {
		mess := fmt.Sprint("removeContact: contactRepo.RemoveContact(id): ", err.Error())
		callErr(mess)
	}
	txparams := struct {
		Error bool `json:"error"`
	}{
		Error: false,
	}
	call(txparams)
}

func getContactsPageCategoryState(contactRepo repoi.ContactRepoI, paramsRX *getContactsPageParams, call lpc.CallRendererBackFunc) {
	rr, err := contactRepo.GetContacts()
	if err != nil {
		txparams := struct {
			Error   bool   `json:"error"`
			Message string `json:"message"`
			State   uint64 `json:"state"`
		}{
			Error:   true,
			Message: fmt.Sprint("getContactsPageCategoryState: contactRepo.GetContacts(): ", err.Error()),
			State:   paramsRX.State,
		}
		call(txparams)
		return
	}
	tracker := make(map[string]*records.ContactRecord)
	keys := make([]string, 0, 5)
	for _, r := range rr {
		if _, ok := tracker[r.State]; !ok {
			tracker[r.State] = r
			keys = append(keys, r.State)
		}
	}
	sort.Strings(keys)
	l := uint64(len(keys))
	states := make([]*records.ContactRecord, l, l)
	for i, state := range keys {
		states[i] = tracker[state]
	}
	start := paramsRX.Index
	end := start + paramsRX.PageSize
	if start > l {
		start = 0
		end = 0
	} else {
		if end > l {
			end = l
		}
	}
	txparams := struct {
		Error       bool                     `json:"error"`
		State       uint64                   `json:"state"`
		Records     []*records.ContactRecord `json:"records"`
		Index       uint64                   `json:"index"`
		RecordCount uint64                   `json:"recordCount"`
	}{
		Error:       false,
		State:       paramsRX.State,
		Records:     states[start:end],
		Index:       paramsRX.Index,
		RecordCount: uint64(len(rr)),
	}
	call(txparams)
	return
}

func getContactsPageCategoryCity(contactRepo repoi.ContactRepoI, paramsRX *getContactsPageParams, call lpc.CallRendererBackFunc) {
	rr, err := contactRepo.GetContacts()
	if err != nil {
		txparams := struct {
			Error   bool   `json:"error"`
			Message string `json:"message"`
			State   uint64 `json:"state"`
		}{
			Error:   true,
			Message: fmt.Sprint("getContactsPageCategoryCity: contactRepo.GetContacts(): ", err.Error()),
			State:   paramsRX.State,
		}
		call(txparams)
		return
	}
	tracker := make(map[string]*records.ContactRecord)
	keys := make([]string, 0, 5)
	for _, r := range rr {
		if r.State == paramsRX.StateMatch {
			if _, ok := tracker[r.City]; !ok {
				tracker[r.City] = r
				keys = append(keys, r.City)
			}
		}
	}
	sort.Strings(keys)
	l := uint64(len(keys))
	cities := make([]*records.ContactRecord, l, l)
	for i, city := range keys {
		cities[i] = tracker[city]
	}
	start := paramsRX.Index
	end := start + paramsRX.PageSize
	if start > l {
		start = 0
		end = 0
	} else {
		if end > l {
			end = l
		}
	}
	txparams := struct {
		Error       bool                     `json:"error"`
		State       uint64                   `json:"state"`
		Records     []*records.ContactRecord `json:"records"`
		Index       uint64                   `json:"index"`
		RecordCount uint64                   `json:"recordCount"`
	}{
		Error:       false,
		State:       paramsRX.State,
		Records:     cities[start:end],
		Index:       paramsRX.Index,
		RecordCount: uint64(len(rr)),
	}
	call(txparams)
	return
}

func getContactsPageMatchStateCity(contactRepo repoi.ContactRepoI, paramsRX *getContactsPageParams, call lpc.CallRendererBackFunc) {
	rr, err := contactRepo.GetContacts()
	if err != nil {
		txparams := struct {
			Error   bool   `json:"error"`
			Message string `json:"message"`
			State   uint64 `json:"state"`
		}{
			Error:   true,
			Message: fmt.Sprint("getContactsPageMatchStateCity: contactRepo.GetContacts(): ", err.Error()),
			State:   paramsRX.State,
		}
		call(txparams)
		return
	}
	matches := make([]*records.ContactRecord, 0, 5)
	for _, r := range rr {
		if r.State == paramsRX.StateMatch && r.City == paramsRX.CityMatch {
			matches = append(matches, r)
		}
	}
	l := uint64(len(matches))
	start := paramsRX.Index
	end := start + paramsRX.PageSize
	if start > l {
		start = 0
		end = 0
	} else {
		if end > l {
			end = l
		}
	}
	txparams := struct {
		Error       bool                     `json:"error"`
		State       uint64                   `json:"state"`
		Records     []*records.ContactRecord `json:"records"`
		Index       uint64                   `json:"index"`
		RecordCount uint64                   `json:"recordCount"`
	}{
		Error:       false,
		State:       paramsRX.State,
		Records:     matches[start:end],
		Index:       paramsRX.Index,
		RecordCount: uint64(len(rr)),
	}
	call(txparams)
	return
}

package main

import (
	"log"
	"net/http"
	"path/filepath"
	"strings"

	"github.com/boltdb/bolt"

	"github.com/josephbudd/kickwasm/examples/contacts/mainprocess/data/filepaths"
	"github.com/josephbudd/kickwasm/examples/contacts/mainprocess/repositories/bolt"
	"github.com/josephbudd/kickwasm/examples/contacts/mainprocess/transports/calls"
	"github.com/josephbudd/kickwasm/examples/contacts/mainprocess/transports/callserver"
)

/*
	This file is generated by kick.
	You are free to edit this file.
	Rekick will always preserve this file for you.

*/

// TODO: Edit port.
const (
	host = "127.0.0.1"
	port = uint(9090)
)

/*

	Repos:
	 * mainprocess/portsi/repoi defines repo interfaces ( repo behaviors ).
	 * mainprocess/ports/boltdatabase is the bolt implementations of the repoi interfaces.
	 * mainprocess/ports/records are the record definitions.

*/

var (
	contactRepo *boltdatabase.ContactBoltDB
)

func main() {
	buildBoltRepos()
	defer contactRepo.Close()
	callsStruct, callsMap := calls.NewCallsAndMap(contactRepo, nil)
	callServer := callserver.NewCallServer(host, port, callsMap, callsStruct)
	callServer.Run(serve)
}

// buildBoltRepos makes bolt data stores.
// Each store is the implementation of an interface defined in package repoi.
// Each store uses the same bolt database so closing one will close all.
func buildBoltRepos() {
	path, err := filepaths.BuildUserSubFoldersPath("boltdb")
	if err != nil {
		log.Fatalf("filepaths.BuildFolderPath error is %q.", err.Error())
	}
	path = filepath.Join(path, "allrepos.nosql")
	db, err := bolt.Open(path, filepaths.GetFmode(), nil)
	if err != nil {
		log.Fatalf("bolt.Open error is %q.", err.Error())
	}
	contactRepo = boltdatabase.NewContactBoltDB(db, path, filepaths.GetFmode())
}

/*

	If you want this main process to serve more then "/", "/css", "wasm".
	Example:

	  * in func serve:
	    case strings.HasPrefix(r.URL.Path, "/widgetcss"):
			withDefaultHeaders(w, r, serveURLPath)

	  * in /renderer:
		* /renderer/widgetcss/vlist.css

	  * in /renderer/templates/head.template ( create it if you haven't already ):
		  <style> @import url(widgetcss/vlist.css); </style>

*/

// serve serves the html file, javascript files, css files.
func serve(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", 405)
		return
	}
	switch {
	case r.URL.Path == "/favicon.ico":
		withDefaultHeaders(w, r, serveFavIconPath)
	case r.URL.Path == "/":
		withDefaultHeaders(w, r, serveMain)
	case strings.HasPrefix(r.URL.Path, "/css"):
		withDefaultHeaders(w, r, serveURLPath)
	case strings.HasPrefix(r.URL.Path, "/widgetcss"):
		withDefaultHeaders(w, r, serveURLPath)
	case strings.HasPrefix(r.URL.Path, "/images"):
		withDefaultHeaders(w, r, serveURLPath)
	case strings.HasPrefix(r.URL.Path, "/wasm"):
		withDefaultWASMHeaders(w, r, serveURLPath)
	default:
		http.Error(w, "Not found", 404)
	}
}

func withDefaultHeaders(w http.ResponseWriter, r *http.Request, fn http.HandlerFunc) {
	header := w.Header()
	header.Set("Cache-Control", "no-cache")
	fn(w, r)
}

func withDefaultWASMHeaders(w http.ResponseWriter, r *http.Request, fn http.HandlerFunc) {
	header := w.Header()
	header.Set("Cache-Control", "no-cache")
	header.Set("Content-Type", "application/wasm")
	fn(w, r)
}

func serveFavIconPath(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, filepaths.GetFaviconPath())
}

func serveMain(w http.ResponseWriter, r *http.Request) {
	// func serveMainHTML is in panelMap.go
	serveMainHTML(w)
}

func serveURLPath(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, filepaths.BuildRendererPath(r.URL.Path))
}

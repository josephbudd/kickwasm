// +build js, wasm

package viewtools

import (
	"fmt"
	"strconv"
	"strings"
	"syscall/js"

	"github.com/josephbudd/kickwasm/examples/colors/rendererprocess/api/event"
	"github.com/josephbudd/kickwasm/examples/colors/rendererprocess/framework/callback"
)

/*
	WARNING:

	DO NOT EDIT THIS FILE.

*/

var (
	tabButtonFloaterOriginal js.Value
	tabButtonFloater         js.Value
	tabButtonFloaterUniqueID = callback.NewEventHandlerID()
)

// ForceTabButtonClick implements the behavior of a tab button being clicked by the user.
func ForceTabButtonClick(button js.Value) {
	handleTabButtonOnClick(button)
}

func initializeTabBar() {
	tabberLastPanelID = ""
	tabberTabBarLastPanel = make(map[string]string, 20)

	for id := range tabberTabBarLastPanel {
		if len(id) > 0 {
			mousedown := func(e event.Event) (nilReturn interface{}) {
				if e.JSTarget.Get("tagName").String() != "BUTTON" {
					// The tab button is not known so ignore.
					return
				}
				tabButtonFloaterOriginal = e.JSTarget
				e.PreventDefaultBehavior()
				e.StopAllPhasePropagation()
				if !handleTabButtonOnClick(e.JSTarget) {
					return
				}
				tabBar := e.JSTarget.Get("parentNode")
				formatTabBarTabs(tabBar)
				floatTab(tabBar, e.JSEvent.Get("clientX").Float(), e.JSEvent.Get("clientY").Float())
				if tabButtonFloaterOriginal.IsUndefined() {
					// The user did not hold the mouse button down.
					//  See mouseup below. It set tabButtonFloaterOriginal to js.Undefined() as a signal.
					tabBar.Call("removeChild", tabButtonFloater)
					tabButtonFloater = js.Undefined()
				}
				return
			}
			mouseup := func(e event.Event) (nilReturn interface{}) {
				if e.JSTarget.Get("tagName").String() != "BUTTON" {
					// The tab button is not known so ignore.
					return
				}
				tabButtonFloaterOriginal = js.Undefined()
				e.PreventDefaultBehavior()
				e.StopAllPhasePropagation()
				return
			}
			tabbar := getElementByID(document, id)
			callback.AddEventHandler(mousedown, tabbar, "mousedown", false, 0)
			callback.AddEventHandler(mouseup, tabbar, "mouseup", false, 0)
		}
	}
}

func handleTabButtonOnClick(button js.Value) (handling bool) {
	if handling = HandleButtonClick(); !handling {
		return
	}
	setTabButtonFocus(button)
	nextpanelid := button.Get("id").String() + "Panel"
	if nextpanelid != tabberLastPanelID {
		// clear this level
		parts := strings.Split(nextpanelid, "-")
		nextpanellevel := parts[0]
		if _, handling = tabberTabBarLastPanel[nextpanellevel]; !handling {
			return
		}
		IDHide(tabberTabBarLastPanel[nextpanellevel])
		// show the next panel
		IDShow(nextpanelid)
		// remember next panel. it is now the last panel.
		tabberLastPanelID = nextpanelid
		tabberTabBarLastPanel[nextpanellevel] = nextpanelid
	}
	SizeApp()
	return
}

func setTabButtonFocus(tabinfocus js.Value) {
	// focus the tab now in focus
	classList := tabinfocus.Get("classList")
	classList.Call("add", SelectedTabClassName)
	p := tabinfocus.Get("parentNode")
	children := p.Get("children")
	l := children.Length()
	for i := 0; i < l; i++ {
		ch := children.Index(i)
		tagName := ch.Get("tagName").String()
		if !ch.Equal(tabinfocus) && tagName == "BUTTON" {
			classList := ch.Get("classList")
			classList.Call("remove", SelectedTabClassName)
		}
	}
}

func formatTabBarTabs(tabBar js.Value) {
	tabBarBoundingClient := tabBar.Call("getBoundingClientRect")
	left := tabBarBoundingClient.Get("left").Float()
	tabBarTop := tabBarBoundingClient.Get("top").Float()
	// Lineup the buttons.
	children := tabBar.Get("children")
	l := children.Length()
	for i := 0; i < l; i++ {
		ch := children.Call("item", i)
		// Don't size the .floater.
		if ch.Equal(tabButtonFloater) {
			continue
		}
		tabBoundingClient := ch.Call("getBoundingClientRect")
		style := ch.Get("style")
		style.Set("position", "fixed")
		style.Set("left", left)
		tabTop := tabBarTop
		style.Set("top", tabTop)
		tabWidth := tabBoundingClient.Get("width").Float()
		left += tabWidth + 2.0
	}
}

// floatTab floats a draggable above the tab and under the mouse pointer.
func floatTab(bar js.Value, clientX, clientY float64) {
	children := bar.Get("children")
	l := children.Length()
	for i := 0; i < l; i++ {
		ch := children.Call("item", i)
		chRectangle := ch.Call("getBoundingClientRect")
		if containsPoint(chRectangle, clientX, clientY) {
			tabButtonFloater = cloneTabIntoFloater(ch, clientX)
			bar.Call("appendChild", tabButtonFloater)
			return
		}
	}
	// Didn't float anything.
}

func cloneTabIntoFloater(tabJS js.Value, lastClientX float64) (cloneJS js.Value) {
	cloneJS = buildTabFloaterJS(tabJS, lastClientX)
	srcStyle := tabJS.Get("style")
	cloneStyle := cloneJS.Get("style")
	// zIndex
	var srcZIndex int
	var err error
	if srcZIndex, err = strconv.Atoi(srcStyle.Get("zIndex").String()); err != nil {
		srcZIndex = 0
	}
	cloneStyle.Set("zIndex", srcZIndex+1)
	// left, top
	rectangle := tabJS.Call("getBoundingClientRect")
	cloneStyle.Set("left", rectangle.Get("left").Float())
	cloneStyle.Set("top", rectangle.Get("top").Float())
	cloneStyle.Set("position", "fixed")
	// opacity
	cloneStyle.Set("opacity", "0.5")
	callback.AddEventHandler(onTabFloaterMouseMove, cloneJS, "mousemove", false, tabButtonFloaterUniqueID)
	callback.AddEventHandler(onTabFloaterMouseUp, cloneJS, "mouseup", false, tabButtonFloaterUniqueID)
	callback.AddEventHandler(onTabFloaterMouseLeave, cloneJS, "mouseleave", false, tabButtonFloaterUniqueID)
	return
}

func buildTabFloaterJS(src js.Value, lastClientX float64) (clone js.Value) {
	var l, i int
	// Clone this element.
	srcTagName := src.Get("tagName").String()
	clone = document.Call("createElement", srcTagName)
	clone.Call("setAttribute", "src-id", src.Get("id").String())
	clone.Call("setAttribute", "unique-id", fmt.Sprintf("%d", tabButtonFloaterUniqueID))
	clone.Call("setAttribute", "lastClientX", fmt.Sprintf("%f", lastClientX))
	if innerText := src.Get("innerText").String(); len(innerText) > 0 {
		clone.Set("innerText", innerText)
	}
	cloneClassList := clone.Get("classList")
	srcClassList := src.Get("classList")
	l = srcClassList.Length()
	for i = 0; i < l; i++ {
		class := srcClassList.Call("item", i).String()
		cloneClassList.Call("add", class)
	}
	cloneClassList.Call("add", "floater")
	// Clone the children.
	srcChildren := src.Get("children")
	l = srcChildren.Length()
	for i = 0; i < l; i++ {
		srcChild := srcChildren.Call("item", i)
		cloneChild := buildTabFloaterChildJS(srcChild)
		clone.Call("appendChild", cloneChild)
	}
	return
}

func buildTabFloaterChildJS(src js.Value) (clone js.Value) {
	var l, i int
	// Clone this element.
	srcTagName := src.Get("tagName").String()
	clone = document.Call("createElement", srcTagName)
	if innerText := src.Get("innerText").String(); len(innerText) > 0 {
		clone.Set("innerText", innerText)
	}
	cloneClassList := clone.Get("classList")
	srcClassList := src.Get("classList")
	l = srcClassList.Length()
	for i = 0; i < l; i++ {
		class := srcClassList.Call("item", i).String()
		cloneClassList.Call("add", class)
	}
	// Clone the children.
	srcChildren := src.Get("children")
	l = srcChildren.Length()
	for i = 0; i < l; i++ {
		srcChild := srcChildren.Call("item", i)
		cloneChild := buildTabFloaterChildJS(srcChild)
		clone.Call("appendChild", cloneChild)
	}
	return
}

func onTabFloaterMouseMove(e event.Event) (nilReturn interface{}) {
	// See rendererprocess/api/event/event.go.
	// The event.Event funcs.
	//   e.PreventDefaultBehavior()
	//   e.StopCurrentPhasePropagation()
	//   e.StopAllPhasePropagation()
	//   target := e.JSTarget
	//   event := e.JSEvent
	// You must use the javascript event e.JSEvent, as a js.Value.
	// However, you can use the target as a js.Value
	//   target := document.NewElementFromJSValue(e.JSTarget)

	var attrString string
	var lastClientX float64
	var err error

	e.PreventDefaultBehavior()
	e.StopAllPhasePropagation()
	clientX := e.JSEvent.Get("clientX").Float()
	floater := e.JSTarget

	// lastClientX
	attrString = floater.Call("getAttribute", "lastClientX").String()
	if lastClientX, err = strconv.ParseFloat(attrString, 64); err != nil {
		lastClientX = 0.0
	}
	floater.Call("setAttribute", "lastClientX", fmt.Sprintf("%f", clientX))
	// delta is the amount of movement.
	delta := clientX - lastClientX // <0==left, >0==right

	// Find the left and right limits.
	bar := floater.Get("parentNode")
	barRectangle := bar.Call("getBoundingClientRect")
	floaterRectangle := e.JSTarget.Call("getBoundingClientRect")

	barLeft := barRectangle.Get("left").Float()
	barRight := barLeft + barRectangle.Get("width").Float()
	maxLeft := barRight - floaterRectangle.Get("width").Float()
	floaterLeft := floaterRectangle.Get("left").Float()
	newLeft := floaterLeft + delta
	if newLeft < barLeft {
		newLeft = barLeft
		// Stop and drop.
	} else if newLeft > maxLeft {
		newLeft = maxLeft
		// Stop and drop.
	}

	// Move the floater.
	style := e.JSTarget.Get("style")
	style.Set("left", newLeft)

	// Highlight the tab under the floater.
	srcID := floater.Call("getAttribute", "src-id").String()
	originalJS := document.Call("getElementById", srcID)
	children := bar.Get("children")
	under, moved := tabUnderFloater(floater, originalJS, children)
	l := children.Length() - 1 // last tab is really the floater.
	for i := 0; i < l; i++ {
		tab := children.Call("item", i)
		classList := tab.Get("classList")
		if !tab.Equal(under) {
			if !tab.Equal(originalJS) {
				classList.Call("remove", UnderTabClassName)
			}
		} else {
			if !tab.Equal(originalJS) {
				if !classList.Call("contains", UnderTabClassName).Bool() {
					classList.Call("add", UnderTabClassName)
				}
			}
		}
	}
	if !moved {
		return
	}
	if originalJS.Equal(under) {
		// The floater is over it's original so do nothing.
		return
	}

	return
}

func onTabFloaterMouseUp(e event.Event) (nilReturn interface{}) {
	// See rendererprocess/api/event/event.go.
	// The event.Event funcs.
	//   e.PreventDefaultBehavior()
	//   e.StopCurrentPhasePropagation()
	//   e.StopAllPhasePropagation()
	//   target := e.JSTarget
	//   event := e.JSEvent
	// You must use the javascript event e.JSEvent, as a js.Value.
	// However, you can use the target as a js.Value
	//   target := document.NewElementFromJSValue(e.JSTarget)

	e.PreventDefaultBehavior()
	e.StopAllPhasePropagation()
	floater := e.JSTarget
	bar := floater.Get("parentNode")
	children := bar.Get("children")
	srcID := floater.Call("getAttribute", "src-id").String()
	originalJS := document.Call("getElementById", srcID)
	under, moved := tabUnderFloater(floater, originalJS, children)
	bar.Call("removeChild", floater)
	if originalJS.Equal(under) {
		// The floater is over it's original so do nothing.
		return
	}
	if !under.IsUndefined() {
		// Reset the class.
		classList := under.Get("classList")
		classList.Call("remove", UnderTabClassName)
		if !moved {
			return
		}
		// The floater is over a tab.
		bar.Call("removeChild", originalJS)
		bar.Call("insertBefore", originalJS, under)
		tabButtonFloaterOriginal = js.Undefined()
		tabButtonFloater = js.Undefined()
		formatTabBarTabs(bar)
		return
	}
	if !moved {
		return
	}
	// The floater is not over a tab.
	// The user dragged the floater to the end of the tabs.
	bar.Call("removeChild", originalJS)
	bar.Call("appendChild", originalJS)
	tabButtonFloaterOriginal = js.Undefined()
	tabButtonFloater = js.Undefined()
	formatTabBarTabs(bar)
	return
}

func tabUnderFloater(floater, original, tabs js.Value) (under js.Value, moved bool) {
	floaterRectangle := floater.Call("getBoundingClientRect")
	x := floaterRectangle.Get("left").Float() + (floaterRectangle.Get("width").Float() / 2.0)
	y := floaterRectangle.Get("top").Float() + (floaterRectangle.Get("height").Float() / 2.0)
	l := tabs.Length() - 1 // last is the floater not really a tab.
	next := -1
	for i := 0; i < l; i++ {
		under = tabs.Call("item", i)
		if under.Equal(original) {
			next = i + 1
		}
		rectangle := under.Call("getBoundingClientRect")
		if containsPoint(rectangle, x, y) {
			if !under.Equal(original) {
				moved = true
			}
			if i == next {
				moved = false
			}
			return
		}
	}
	// Moved past the last tab.
	moved = true
	under = js.Undefined()
	return
}

func onTabFloaterMouseLeave(e event.Event) (nilReturn interface{}) {
	// See rendererprocess/api/event/event.go.
	// The event.Event funcs.
	//   e.PreventDefaultBehavior()
	//   e.StopCurrentPhasePropagation()
	//   e.StopAllPhasePropagation()
	//   target := e.JSTarget
	//   event := e.JSEvent
	// You must use the javascript event e.JSEvent, as a js.Value.
	// However, you can use the target as a js.Value
	//   target := document.NewElementFromJSValue(e.JSTarget)

	e.PreventDefaultBehavior()
	e.StopAllPhasePropagation()
	floater := e.JSTarget
	bar := floater.Get("parentNode")
	bar.Call("removeChild", floater)
	tabButtonFloaterOriginal = js.Undefined()
	tabButtonFloater = js.Undefined()
	return
}

// reformatTabBarTabs is called during tab spawning and unspawning.
func reformatTabBarTabs(tabBar js.Value) {
	tabBarBoundingClient := tabBar.Call("getBoundingClientRect")
	left := tabBarBoundingClient.Get("left").Float()
	tabBarTop := tabBarBoundingClient.Get("top").Float()
	// Lineup the buttons.
	children := tabBar.Get("children")
	l := children.Length()
	for i := 0; i < l; i++ {
		ch := children.Call("item", i)
		tabBoundingClient := ch.Call("getBoundingClientRect")
		style := ch.Get("style")
		style.Set("position", "fixed")
		style.Set("left", left)
		tabTop := tabBarTop
		style.Set("top", tabTop)
		tabWidth := tabBoundingClient.Get("width").Float()
		left += tabWidth + 2.0
	}
}

// +build js, wasm

package lpc

import (
	"fmt"
	"syscall/js"

	"github.com/pkg/errors"

	"github.com/josephbudd/kickwasm/examples/push/rendererprocess/viewtools"
)

/*
	DO NOT EDIT THIS FILE.

	USE THE TOOL kicklpc TO ADD OR REMOVE LPC Messages.

	kicklpc will edit this file for you.

*/

// Client is a wasm local process communication client.
type Client struct {
	host           string
	port           uint64
	location       string
	tools          *viewtools.Tools
	connection     js.Value
	connected      bool
	dispatching    bool
	queue          [][]byte
	OnOpenCallBack func()

	SendChan    Sending
	ReceiveChan Receiving
	EOJChan     chan struct{}
	QuitCh      chan struct{}

	// OnOpenCallBack func()
	lpcing bool

	// handlers
	OnConnectionBreakJS js.Func
	OnConnectionBreak   func(this js.Value, args []js.Value) interface{}
}

// NewClient costructs a new Client.
func NewClient(host string, port uint64, tools *viewtools.Tools, quitCh chan struct{}, eojCh chan struct{}, receiving Receiving, sending Sending) *Client {
	v := &Client{
		host:     host,
		port:     port,
		location: fmt.Sprintf("ws://%s:%d/ws", host, port),
		tools:    tools,
		queue:    make([][]byte, 0, 10),

		SendChan:    sending,
		ReceiveChan: receiving,
		EOJChan:     eojCh,
		QuitCh:      quitCh,
	}
	// Shut the renderer down when the connection breaks.
	v.SetOnConnectionBreak(
		func(event js.Value, args []js.Value) (nilReturn interface{}) {
			quitCh <- struct{}{}
			return
		},
	)
	return v
}

// SetOnConnectionBreak set the handler for the connection break.
func (client *Client) SetOnConnectionBreak(fn func(this js.Value, args []js.Value) interface{}) {
	client.OnConnectionBreak = fn
	client.OnConnectionBreakJS = client.tools.RegisterCallBack(fn)
}

// Connect connects to the server.
func (client *Client) Connect(callBack func()) (err error) {

	defer func() {
		if err != nil {
			err = errors.WithMessage(err, "client.Connect")
		}
	}()

	client.OnOpenCallBack = callBack
	if client.connected {
		client.tools.ConsoleLog("client is connected")
	}
	// setup the web socket
	ws := client.tools.Global.Get("WebSocket")
	client.connection = ws.New(client.location)
	if client.connection == js.Undefined() {
		err = errors.New("connection is undefined")
		return
	}
	rs := client.connection.Get("readyState")
	if rs.String() == "undefined" {
		err = errors.New("readystate is undefined")
		return
	}
	client.connection.Set("onopen", client.tools.RegisterCallBack(client.onOpen))
	client.connection.Set("onclose", client.tools.RegisterCallBack(client.onClose))
	client.connection.Set("onmessage", client.tools.RegisterCallBack(client.onMessage))
	return
}

func (client *Client) dispatch() {
	if client.dispatching {
		return
	}
	client.dispatching = len(client.queue) > 0
	for client.dispatching {
		payload := client.queue[0]
		client.queue = client.queue[1:]
		var cargo interface{}
		var err error
		if cargo, err = client.ReceiveChan.Cargo(payload); err != nil {
			client.tools.Alert(err.Error())
			return
		}
		panelsCount := client.tools.CountMarkupPanels()
		for i := 0; i < panelsCount; i++ {
			client.ReceiveChan <- cargo
		}
		client.dispatching = len(client.queue) > 0
	}
}

// Handlers.

func (client *Client) onBreak(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.QuitCh <- struct{}{}
	return
}

func (client *Client) onOpen(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.connected = true
	client.tools.ConsoleLog("LPC has connected.")
	if client.lpcing {
		return
	}
	client.lpcing = true
	client.tools.ConsoleLog("starting LPC go routine.")
	go func() {
		for {
			select {
			case cargo := <-client.SendChan:
				client.tools.ConsoleLog("will send lpc cargo to main process")
				var payload []byte
				var err error
				if payload, err = client.SendChan.Payload(cargo); err != nil {
					client.tools.ConsoleLog(fmt.Sprintf("sending.Payload(cargo) error is %s", err.Error()))
				} else {
					client.tools.ConsoleLog("payload is " + string(payload))
					client.connection.Call("send", string(payload))
				}
			case <-client.QuitCh:
				// each markup panel has a messenger with a message dispatcher go routine.
				countWaiting := client.tools.CountMarkupPanels()
				// func main
				countWaiting++
				// widgets
				countWaiting += client.tools.CountWidgetsWaiting()
				eoj := struct{}{}
				for i := 0; i < countWaiting; i++ {
					client.EOJChan <- eoj
				}
				client.lpcing = false
				return
			}
		}
	}()
	client.OnOpenCallBack()
	return
}

func (client *Client) onClose(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.connected = false
	client.tools.ConsoleLog("LPC has disconnected.")
	client.OnConnectionBreak(js.Undefined(), nil)
	return
}

func (client *Client) onMessage(this js.Value, args []js.Value) (nilReturn interface{}) {
	e := args[0]
	data := e.Get("data").String()
	client.queue = append(client.queue, []byte(data))
	client.dispatch()
	return
}

package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"

	"github.com/josephbudd/kickwasm/examples/spawntabs/domain/data/settings"
	"github.com/josephbudd/kickwasm/examples/spawntabs/domain/store"
	"github.com/josephbudd/kickwasm/examples/spawntabs/mainprocess/lpc"
	"github.com/josephbudd/kickwasm/examples/spawntabs/mainprocess/lpc/dispatch"
)

/*
	DO NOT EDIT THIS FILE.

	kicklpc and kickstore will alter this file.

*/

/*

	Data Storage:
	 * /domain/store/storer is the storer interfaces.
	 * /domain/store/storing is the bolt implementations of the storer interfaces.
	 * /domain/store/record is the record definitions.

*/
func main() {

	var err error
	defer func() {
		if err != nil {
			os.Exit(1)
		}
	}()

	// Build the application's data store APIs.
	var stores *store.Stores
	if stores, err = buildStores(); err != nil {
		log.Println(err)
		return
	}
	// Open the stores.
	if err = stores.Open(); err != nil {
		log.Println(err)
		return
	}
	// Close the stores later.
	defer stores.Close()

	// get the application's host and port and then setup the listener.
	var appSettings *settings.ApplicationSettings
	if appSettings, err = settings.NewApplicationSettings(); err != nil {
		log.Println(err)
		return
	}

	// initialize and start the listener.
	// the listener may have reset the address if "localhost:0".
	// use the listener's address.
	location := fmt.Sprintf("%s:%d", appSettings.Host, appSettings.Port)
	var listener net.Listener
	if listener, err = net.Listen("tcp", location); err != nil {
		log.Println(err)
		return
	}
	// get the channels
	sendChan, receiveChan := lpc.Channels()
	serverStoppedChan := make(chan struct{}, 1)
	exitChan := make(chan struct{}, 1)
	ctx, cancel := context.WithCancel(context.Background())
	// process incoming lpcs.
	go func() {
		handlerErrorChan := make(chan error, 10)
		var er error
		// Wait for the lpc message server to stop.
		for {
			select {
			case cargo := <-receiveChan:
				// dispatch.Do returns the error through handlerErrorChan.
				go dispatch.Do(ctx, cargo, sendChan, stores, handlerErrorChan)
			case er = <-handlerErrorChan:
				// handle the error sent from a message handler and keep going.
				if er != nil {
					err = er
					log.Println(err)
				}
			case <-serverStoppedChan:
				// signal to exit.
				exitChan <- struct{}{}
				return
			}
		}
	}()

	// make the lpc message server.
	server := lpc.NewServer(listener, serverStoppedChan, receiveChan, sendChan)
	server.Run(serve)
	select {
	case <-exitChan:
		// stop all lpc message handlers.
		cancel()
		break
	}
}

package templates

// RebuildDispatchGo is mainprocess/lpc/dispatch/dispatch.go.
const RebuildDispatchGo = `package dispatch

import (
	"context"
	"log"
	"time"

	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
	"{{.ApplicationGitPath}}{{.ImportDomainStore}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPC}}"
)

var startedCh = make(chan struct{}, 1)

/*
	DO NOT EDIT THIS FILE.

	USE THE TOOL kicklpc TO ADD OR REMOVE LPC Messages.

	kicklpc will edit this file for you.

*/

func init() {
	go worry()
}

// Do dispatches local process communications messages received from the renderer.
// They are dispatched to the main process handlers here in package dispatch.
// You are required to code the functionality into those handlers.
func Do(ctx context.Context, cargo interface{}, sending lpc.Sending, stores *store.Stores, errChan chan error) {
	switch cargo := cargo.(type) {
	case *message.LogRendererToMainProcess:
		handleLog(ctx, cargo, sending, errChan)
	case *message.InitRendererToMainProcess:
		// Init signals that
		// * the renderer process is up and running,
		// * the main process may push messages to the renderer process.
		startedCh <- struct{}{}
		handleInit(ctx, cargo, sending, stores, errChan){{ range .LPCNames }}
	case *message.{{.}}RendererToMainProcess:
		handle{{.}}(ctx, cargo, sending, stores, errChan){{ end }}
	default:
		log.Println("dispatch Do: unknown cargo type.")
	}
	return
}

func worry() {
	// If the renderer process hasn't started after 5 seconds
	//  then inform the user to manually start it.
	t := time.After(5 * time.Second)
	select {
	case <-startedCh:
		break
	case <-t:
		log.Println(lpc.WorryMessage)
	}
}

`

// DispatchInstructions is the mainprocess/lpc/dispatch/instructions.txt.
const DispatchInstructions = `
ABOUT THE FILES IN THE FOLDER mainprocess/lpc/dispatch/.

  * dispatch.go contains func Do which dispatches the LPC ( Local Process Communications ) messages received from the renderer.
    Do not edit the file dispatch.go.
    In func Do, the messages are dispatched to the LPC message handlers also in mainprocess/lpc/dispatch/.

  Message handler files:

  * mainprocess/lpc/dispatch/Init.go was generated by kickwasm when this framework was created.
    The file contains func handleInit(ctx context.Context, rxMessage *message.InitRendererToMainProcess, sending lpc.Sending, stores *store.Stores, errChan chan error).
    kickwasm created func handleInit void of any functionality so that it's functionality could to be coded.
    You could for example, start a main process home which pushes messages to the renderer process.
    You may edit the file if you need to give func handleInit functionality.

  * mainprocess/lpc/dispatch/Log.go was generated by kickwasm when this framework was created.
    The file contains func handleLog(ctx context.Context, rxMessage *message.LogRendererToMainProcess, sending lpc.Sending, errChan chan error)
      which processes the log message received from the renderer.
    You may edit the file if you need to.{{ range .LPCNames }}

  * mainprocess/lpc/dispatch/{{.}}.go was generated by kicklpc when you added the {{.}} LPC message.
    The file contains func handle{{.}}(ctx context.Context, rxmessage *message.{{.}}RendererToMainProcess, sending lpc.Sending, stores *store.Stores, errChan chan error)
      which must process the {{.}} message received from the renderer.
    kicklpc created func handle{{.}} void of any functionality so that it's functionality could to be coded.
    There fore, you may edit {{.}}.go.{{ end }}

ABOUT THE FILES IN THE FOLDER domain/lpc/message/.

* Init.go was generated by kickwasm when this framework was created.
  The file contains the types of the 2 Init messages.
  1. InitRendererToMainProcess is the message that the renderer sends to the main process.
     The message signals that
     * the renderer process is up and running,
     * the main process may push messages to the renderer process.
     The message is sent from rendererprocess/Main.go which you can edit.
  2. LogMainProcessToRenderer is the message that the main process sends to the renderer.
     * You may or may not have a use for LogMainProcessToRenderer.

* Log.go was generated by kickwasm when this framework was created.
  The file contains the types of the 2 Log messages.
  1. LogRendererToMainProcess is the message that the renderer sends to the main process.
  2. LogMainProcessToRenderer is the message that the main process sends to the renderer.{{ range .LPCNames }}

* {{.}}.go was generated by kicklpc.
  The file contains the types of the 2 {{.}} messages.
  1. {{.}}RendererToMainProcess is the message that the renderer sends to the main process.
  2. {{.}}MainProcessToRenderer is the message that the main process sends to the renderer.
  kicklpc created the 2 {{.}} message types with little or no structure so that their structure could to be completed.
  There fore, you may edit {{.}}.go.{{ end }}

MANAGING LPC MESSAGES WITH kicklpc.

* Use kicklpc in this application's root folder:
  $ cd {{.ApplicationGitPath}}/

* Listing all of the messages:
  $ kicklpc -l
  1. kicklpc would
    * Display the names of each LPC message.

* Adding a message:
  $ kicklpc -add UpdateCustomer
  1. kicklpc would
    * Add the file domain/lpc/UpdateCustomer.go
    * Add the file mainprocess/lpc/dispatch/UpdateCustomer.go
    * Update the file mainprocess/lpc/dispatch/dispatch.go
  2. You would need to
  * Complete the message definitions in domain/lpc/UpdateCustomer.go
  * Complete the func handleUpdateCustomer in mainprocess/lpc/dispatch/UpdateCustomer.go

* Deleting a message:
  $ kicklpc -delete-forever UpdateCustomer
  1. kicklpc would
    * Delete the file domain/lpc/UpdateCustomer.go
    * Delete the file mainprocess/lpc/dispatch/UpdateCustomer.go
    * Update the file mainprocess/lpc/dispatch/dispatch.go
`

// DispatchInitGo is the mainprocess/lpc/dispatch/Init.go.
const DispatchInitGo = `package dispatch

import (
	"context"

	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
	"{{.ApplicationGitPath}}{{.ImportDomainStore}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPC}}"
)

/*
	YOU MAY EDIT THIS FILE.

	Rekickwasm will preserve this file for you.
	Kicklpc will not edit this file.

*/

// handleInit is the *message.InitRendererToMainProcess handler.
//   The InitRendererToMainProcess message signals that
//   * the renderer process is up and running,
//   * the main process may push messages to the renderer process.
//   The message is sent from rendererprocess/Main.go which you can edit.
// handleInit's response back to the renderer is the *message.InitMainProcessToRenderer.
// Param ctx is the context. if <-ctx.Done() then the main process is shutting down.
// Param rxmessage *message.InitRendererToMainProcess is the message received from the renderer.
// Param sending is the channel to use to send a *message.InitMainProcessToRenderer message back to the renderer.
// Param stores is a struct the contains each of your stores.
// Param errChan is the channel to send the handler's error through since the handler does not return it's error.
func handleInit(ctx context.Context, rxmessage *message.InitRendererToMainProcess, sending lpc.Sending, stores *store.Stores, errChan chan error) {
	return
}
`

// DispatchLogGo is mainprocess/lpc/dispatch/Log.go.
const DispatchLogGo = `package dispatch

import (
	"context"
	"fmt"
	"log"

	"{{.ApplicationGitPath}}{{.ImportDomainDataLogLevels}}"
	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPC}}"
)

/*
	YOU MAY EDIT THIS FILE.

	Rekickwasm will preserve this file for you.
	Kicklpc will not edit this file.

*/

// handleLog logs a renderer message to the application log.
// Param ctx is the context. if <-ctx.Done() then the main process is shutting down.
// Param rxMessage *message.LogRendererToMainProcess is the params received from the renderer.
// Param sending is the channel to use to send a *message.LogMainProcessToRenderer to the renderer.
// Builds an error for loglevels.LogLevelError and loglevels.LogLevelFatal.
// Param errChan is the channel to send the handler's error through since the handler does not return it's error.
func handleLog(ctx context.Context, rxMessage *message.LogRendererToMainProcess, sending lpc.Sending, errChan chan error) {

	var err error
	defer func() {
		if err != nil {
			errChan <- err
		}
	}()
	
	var msg string
	switch rxMessage.Level {
	case loglevels.LogLevelInfo:
		msg = "{{.ApplicationName}}: Info: " + rxMessage.Message
	case loglevels.LogLevelWarning:
		msg = "{{.ApplicationName}}: Warning: " + rxMessage.Message
	case loglevels.LogLevelError:
		msg = "{{.ApplicationName}}: Error: " + rxMessage.Message
		err = fmt.Errorf(msg)
	case loglevels.LogLevelFatal:
		msg = "{{.ApplicationName}}: Fatal: " + rxMessage.Message
		err = fmt.Errorf(msg)
	default:
		msg = fmt.Sprintf("{{.ApplicationName}}: %d: %s", rxMessage.Level, rxMessage.Message)
	}
	// Log the message from the renderer.
	log.Println(msg)
	// Send an update back to the renderer.
	txMessage := &message.LogMainProcessToRenderer{
		Level:   rxMessage.Level,
		Message: rxMessage.Message,
		Fatal:   rxMessage.Level == loglevels.LogLevelFatal,
	}
	sending <- txMessage
	return
}
`

// DispatchMessageGo is mainprocess/lpc/dispatch/<Message Name>.go.
// This is only for kickllpc when it adds a new message.
const DispatchMessageGo = `package dispatch

import (
	"context"

	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
	"{{.ApplicationGitPath}}{{.ImportDomainStore}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPC}}"
)

/*
	YOU MAY EDIT THIS FILE.

	Rekickwasm will preserve this file for you.
	Kicklpc will not edit this file.

*/

// handle{{.MessageName}} is the *message.{{.MessageName}}RendererToMainProcess handler.
// It's response back to the renderer is the *message.{{.MessageName}}MainProcessToRenderer.
// Param ctx is the context. if <-ctx.Done() then the main process is shutting down.
// Param rxmessage *message.{{.MessageName}}RendererToMainProcess is the message received from the renderer.
// Param sending is the channel to use to send a *message.{{.MessageName}}MainProcessToRenderer message back to the renderer.
// Param stores is a struct the contains each of your stores.
// Param errChan is the channel to send the handler's error through since the handler does not return it's error.
func handle{{.MessageName}}(ctx context.Context, rxmessage *message.{{.MessageName}}RendererToMainProcess, sending lpc.Sending, stores *store.Stores, errChan chan error) {
	return
}
`

package templates

// MainGo is the main.go template.
const MainGo = `{{$Dot := .}}package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"

	"{{.ApplicationGitPath}}{{.ImportDomainDataSettings}}"
	"{{.ApplicationGitPath}}{{.ImportDomainStore}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPC}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessLPCDispatch}}"
)

/*
	DO NOT EDIT THIS FILE.

	kicklpc and kickstore will alter this file.

*/

/*

	Data Storage:
	 * {{.ImportDomainStoreStorer}} is the storer interfaces.
	 * {{.ImportDomainStoreStoring}} is the bolt implementations of the storer interfaces.
	 * {{.ImportDomainStoreRecord}} is the record definitions.

*/
func main() {

	var err error
	defer func() {
		if err != nil {
			os.Exit(1)
		}
	}()

	// Build the application's data store APIs.
	var stores *store.Stores
	if stores, err = buildStores(); err != nil {
		log.Println(err)
		return
	}
	// Open the stores.
	if err = stores.Open(); err != nil {
		log.Println(err)
		return
	}
	// Close the stores later.
	defer stores.Close()

	// get the application's host and port and then setup the listener.
	var appSettings *settings.ApplicationSettings
	if appSettings, err = settings.NewApplicationSettings(); err != nil {
		log.Println(err)
		return
	}

	// initialize and start the listener.
	// the listener may have reset the address if "localhost:0".
	// use the listener's address.
	location := fmt.Sprintf("%s:%d", appSettings.Host, appSettings.Port)
	var listener net.Listener
	if listener, err = net.Listen("tcp", location); err != nil {
		log.Println(err)
		return
	}
	// get the channels
	sendChan, receiveChan := lpc.Channels()
	serverStoppedChan := make(chan struct{}, 1)
	exitChan := make(chan struct{}, 1)
	ctx, cancel := context.WithCancel(context.Background())
	// process incoming lpcs.
	go func() {
		handlerErrorChan := make(chan error, 10)
		var er error
		// Wait for the lpc message server to stop.
		for {
			select {
			case cargo := <-receiveChan:
				// dispatch.Do returns the error through handlerErrorChan.
				go dispatch.Do(ctx, cargo, sendChan, stores, handlerErrorChan)
			case er = <-handlerErrorChan:
				// handle the error sent from a message handler and keep going.
				if er != nil {
					err = er
					log.Println(err)
				}
			case <-serverStoppedChan:
				// signal to exit.
				exitChan <- struct{}{}
				return
			}
		}
	}()

	// make the lpc message server.
	server := lpc.NewServer(listener, serverStoppedChan, receiveChan, sendChan)
	server.Run(serve)
	select {
	case <-exitChan:
		// stop all lpc message handlers.
		cancel()
		break
	}
}
`

// PanelMapGo is the panelMap.go template for package main.
const PanelMapGo = `{{$Dot := .}}package main

import (
	"fmt"
	"html/template"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"{{.ApplicationGitPath}}{{.ImportDomainDataFilepaths}}"
	"{{.SitePackImportPath}}"
)

/*

	DO NOT EDIT THIS FILE.

	This file is generated by kickasm and regenerated by rekickasm.

*/

const (
	mainTemplate = "main.tmpl"
	headTemplate = "{{.FileNames.HeadDotTMPL}}"
)

// homeEmptyInsidePanelNamePathMap maps each markup panel template name to it's file path.
var homeEmptyInsidePanelNamePathMap = {{.HomeEmptyInsidePanelNamePathMap}}

// serveMainHTML only serves up main.tmpl with all of the templates for your markup panels.
func serveMainHTML(w http.ResponseWriter) {
	var err error
	var masterT, tmpl *template.Template
	var tpath, s string
	var bb []byte
	var found bool
	var fname string
	var l int

	templateFolderPath := filepaths.GetShortTemplatePath()
	// main.tmpl
	tpath = filepath.Join(templateFolderPath, mainTemplate)
	if bb, found = {{.SitePackPackage}}.Contents(tpath); !found {
		http.Error(w, fmt.Sprintf("Not found. (%s)", mainTemplate), 404)
		return
	}
	l += len(bb)
	masterT = template.New(mainTemplate)
	s = string(bb)
	if _, err = masterT.Parse(s); err != nil {
		http.Error(w, err.Error(), 300)
		return
	}
	// head.tmpl
	// the head template which contains
	//  * any css imports
	//  * any javascript imports
	tpath = filepath.Join(templateFolderPath, headTemplate)
	if bb, found = {{.SitePackPackage}}.Contents(tpath); !found {
		// add a head.tmpl template
		// it's ok if the template is not there
		// but if it's there use it.
		bb = []byte(fmt.Sprintf("%[1]s%[1]s define %[3]q %[2]s%[2]s<!-- You do not have a %[3]s file to import any files you added in the site/ folder. Feel free to add a %[3]s file in the site/template folder. -->%[1]s%[1]s end %[2]s%[2]s", "{", "}", headTemplate))
	}
	tmpl = masterT.New(headTemplate)
	l += len(bb)
	s = string(bb)
	if _, err = tmpl.Parse(s); err != nil {
		http.Error(w, err.Error(), 300)
	}
	// panel template files
	for _, namePathMap := range homeEmptyInsidePanelNamePathMap {
		for name, folders := range namePathMap {
			fname = name + ".tmpl"
			folderPath := strings.Join(folders, string(os.PathSeparator))
			tpath := filepath.Join(templateFolderPath, folderPath, fname)
			if bb, found = {{.SitePackPackage}}.Contents(tpath); !found {
				http.Error(w, fmt.Sprintf("Not found. (%s)", fname), 404)
				return
			}
			l += len(bb)
			tmpl = masterT.New(fname)
			s = string(bb)
			if _, err = tmpl.Parse(s); err != nil {
				http.Error(w, err.Error(), 300)
			}
		}
	}
	// send the html
	if err = masterT.ExecuteTemplate(w, mainTemplate, nil); err != nil {
		if !strings.Contains(err.Error(), "reset") {
			http.Error(w, err.Error(), 300)
		}
	}
}
`

// ServeGo is the serve.go template which is the web server.
const ServeGo = `package main

import (
	"log"
	"mime"
	"net/http"
	"path/filepath"
	"strings"

	"{{.ApplicationGitPath}}{{.ImportDomainDataFilepaths}}"
	"{{.SitePackImportPath}}"
)

const (
	wasmPrefix     = "/wasm"
	wasmExceDotJS  = "/wasm/wasm_exec.js"
	wasmAppDotWASM = "/wasm/app.wasm"
	favicon        = "/favicon.ico"
)

/*

	TODO: Modify func serve for your special needs.

	If for example you want this main process to serve your own css files in /site/widgetcss/.

	  1. In func serve below add the following 2 lines:
	    case strings.HasPrefix(r.URL.Path, "/widgetcss"):
			withDefaultHeaders(w, r, serveURLPath)

	  2. In the /site/ folder add the /widgetcss/ folder
	     Add your css files to the /site/widgetcss/ folder.

	  3. In the /site/templates/ folder create a "head.tmpl" file if you haven't already.
	     In /site/templates/head.tmpl add the line:
		  <style> @import url(widgetcss/vlist.css); </style>

	  4. Rebuild and run.
		 $ kickbuild -rp -mp -run

*/

// serve serves files from renderer folders.
func serve(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", 405)
		return
	}
	switch {
	case r.URL.Path == "/":
		withDefaultHeaders(w, r, serveMain)
	case strings.HasPrefix(r.URL.Path, "/css"):
		withDefaultHeaders(w, r, serveFileStore)
	case strings.HasPrefix(r.URL.Path, "/mycss"):
		withDefaultHeaders(w, r, serveFileStore)
	case r.URL.Path == wasmExceDotJS:
		withDefaultHeaders(w, r, serveFileStore)
	case r.URL.Path == wasmAppDotWASM:
		withDefaultHeaders(w, r, serveFileStore)
	case r.URL.Path == favicon:
		withDefaultHeaders(w, r, serveFileStore)
	default:
		http.Error(w, "Not found", 404)
	}
}

func withDefaultHeaders(w http.ResponseWriter, r *http.Request, fn http.HandlerFunc) {
	header := w.Header()
	header.Set("Cache-Control", "no-cache")
	fn(w, r)
}

func serveMain(w http.ResponseWriter, r *http.Request) {
	// func serveMainHTML is in panelMap.go
	serveMainHTML(w)
}

func serveFileStore(w http.ResponseWriter, r *http.Request) {
	var bb []byte
	var found bool
	var path string
	var urlPath string
	urlPath = r.URL.Path
	// fix url path
	if strings.HasPrefix(urlPath, wasmPrefix) {
		// the wasm prefix is only a flag to use wasm headers.
		// there is no wasm folder.
		urlPath = urlPath[len(wasmPrefix):]
	}
	path = filepath.Join(filepaths.GetShortSitePath(), urlPath)
	if bb, found = {{.SitePackPackage}}.Contents(path); !found {
		if urlPath != favicon {
			log.Printf("404 Error: %q not found", path)
			http.Error(w, "Not found", 404)
		}
		return
	}
	header := w.Header()
	contentType := mime.TypeByExtension(filepath.Ext(urlPath))
	header.Set("Content-Type", contentType)
	var err error
	if _, err = w.Write(bb); err != nil {
		http.Error(w, err.Error(), 300)
	}
}
`

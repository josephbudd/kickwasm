package templates

// MainGo is the main.go template.
const MainGo = `{{$Dot := .}}{{$store0 := index .Stores 0}}package main

import (
	"fmt"
	"log"
	"net"
	"path/filepath"

	"github.com/boltdb/bolt"
	"github.com/pkg/errors"

	"{{.ApplicationGitPath}}{{.ImportDomainDataFilepaths}}"
	"{{.ApplicationGitPath}}{{.ImportDomainDataSettings}}"
	"{{.ApplicationGitPath}}{{.ImportDomainImplementationsStoringBolt}}"
	"{{.ApplicationGitPath}}{{.ImportDomainInterfacesStorers}}"
	"{{.ApplicationGitPath}}{{.ImportDomainTypes}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessCalls}}"
	"{{.ApplicationGitPath}}{{.ImportMainProcessCallServer}}"
)

/*
	YOU MAY EDIT THIS FILE.

	Rekickwasm will preserve this file for you.

	BUILD INSTRUCTIONS:

		cd renderer/
		GOARCH=wasm GOOS=js go build -o app.wasm main.go panels.go
		cd ..
		go build

*/

/*

	Data Storage:
	 * {{.ImportDomainInterfacesStorers}} is the storer interfaces.
	 * {{.ImportDomainImplementationsStoringBolt}} is the bolt implementations of the storer interfaces.
	 * {{.ImportDomainTypes}} is the record definitions.

*/

var ({{range .Stores}}
	{{call $Dot.LowerCamelCase .}}Store storer.{{.}}Storer{{end}}
)

func main() {
	var err error
	// build the stores and setup the close.
	if err = buildBoltStores(); err != nil {
		log.Println(err)
		return
	}{{if eq (len .Stores) 1}}
	// close the bolt store later.{{else}}
	// closing 1 bolt store later. That will close each bolt store because they share the same bolt database.{{end}}
	defer {{call .LowerCamelCase $store0}}Store.Close()
	// get the application's host and port and then setup the listener.
	var appSettings *types.ApplicationSettings
	if appSettings, err = settings.NewApplicationSettings(); err != nil {
		log.Println(err)
		return
	}
	// initialize and start the listener.
	// the listener may have reset the address if "localhost:0".
	// use the listener's address.
	location := fmt.Sprintf("%s:%d", appSettings.Host, appSettings.Port)
	var listener net.Listener
	if listener, err = net.Listen("tcp", location); err != nil {
		log.Println(err)
		return
	}
	// build the callMap
	callMap := calls.GetCallMap({{range $i, $store0 := .Stores}}{{if ne $i 0}}, {{end}}{{call $Dot.LowerCamelCase $store0}}Store{{end}})
	// make the call server and start it.
	callServer := callserver.NewCallServer(listener, callMap)
	callServer.Run(serve)
}

// buildBoltStores makes bolt data stores.
{{if eq (len .Stores) 1}}
// The store is an implementation of an interface defined in package storer.
// Close the bolt store later.{{else}}
// Each store is an implementation of an interface defined in package storer.
// Closing 1 bolt store later, will close each bolt store because they share the same bolt database.{{end}}
func buildBoltStores() (err error) {

	defer func() {
		if err != nil {
			err = errors.WithMessage(err, "buildBoltStores()")
		}
	}()

	var path string
	if path, err = filepaths.BuildUserSubFoldersPath("boltdb"); err != nil {
		err = errors.WithMessage(err, "filepaths.BuildUserSubFoldersPath(\"boltdb\")")
		return
	}
	path = filepath.Join(path, "allstores.nosql")
	var db *bolt.DB
	if db, err = bolt.Open(path, filepaths.GetFmode(), nil); err != nil {
		err = errors.WithMessage(err, "bolt.Open(path, filepaths.GetFmode(), nil)")
		return
	}{{range .Stores}}
	{{call $Dot.LowerCamelCase .}}Store = boltstoring.New{{.}}BoltDB(db, path, filepaths.GetFmode()){{end}}
	return
}

`

// PanelMapGo is the panelMap.go template for package main.
const PanelMapGo = `package main

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"{{.ApplicationGitPath}}{{.ImportDomainDataFilepaths}}"
)

/*

	DO NOT EDIT THIS FILE.

	This file is generated by kickasm and regenerated by rekickasm.

*/

const (
	mainTemplate = "main.tmpl"
	headTemplate = "{{.FileNames.HeadDotTMPL}}"
)

// serviceEmptyInsidePanelNamePathMap maps each markup panel template name to it's file path.
var serviceEmptyInsidePanelNamePathMap = {{.ServiceEmptyInsidePanelNamePathMap}}

// serveMainHTML only serves up main.tmpl with all of the templates for your markup panels.
func serveMainHTML(w http.ResponseWriter) {
	var err error
	templateFolderPath := filepaths.GetTemplatePath()
	var t *template.Template
	t = template.New(mainTemplate)
	if t, err = t.ParseFiles(filepath.Join(templateFolderPath, mainTemplate)); err != nil {
		http.Error(w, err.Error(), 300)
		return
	}
	for _, namePathMap := range serviceEmptyInsidePanelNamePathMap {
		for name, folders := range namePathMap {
			folderPath := strings.Join(folders, string(os.PathSeparator))
			tpath := filepath.Join(templateFolderPath, folderPath, name+".tmpl")
			if t, err = t.ParseFiles(tpath); err != nil {
				http.Error(w, err.Error(), 300)
				return
			}
		}
	}
	// the head template which contains
	//  * any css imports
	//  * any javascript imports
	// needed for this applicaion
	tpath := filepath.Join(templateFolderPath, headTemplate)
	// it's ok if the template is not there
	// but if it's there use it.
	if _, err = os.Stat(tpath); os.IsNotExist(err) {
		// the template file does not exist so inform the developer.
		temp := fmt.Sprintf("%[1]s%[1]s define %[3]q %[2]s%[2]s<!-- You do not have a %[3]s file to import your css files. Feel free to add one in the render/template folder. -->%[1]s%[1]s end %[2]s%[2]s", "{", "}", headTemplate)
		if t, err = t.Parse(temp); err != nil {
			http.Error(w, err.Error(), 300)
			return
		}
	} else {
		// the file exists so parse it
		if t, err = t.ParseFiles(tpath); err != nil {
			http.Error(w, err.Error(), 300)
			return
		}
	}
	// do the template
	if err = t.ExecuteTemplate(w, mainTemplate, nil); err != nil {
		if !strings.Contains(err.Error(), "reset") {
			http.Error(w, err.Error(), 300)
		}
	}
}

`

// ServeGo is the serve.go template which is the web server.
const ServeGo = `package main

import (
	"net/http"
	"strings"

	"{{.ApplicationGitPath}}{{.ImportDomainDataFilepaths}}"
)
/*

	TODO: Modify func serve for your special needs.

	If for example you want this main process to serve your own css files in /site/widgetcss/.

	  1. In func serve below add the following 2 lines:
	    case strings.HasPrefix(r.URL.Path, "/widgetcss"):
			withDefaultHeaders(w, r, serveURLPath)

	  2. In the /site/ folder add the /widgetcss/ folder
	     Add your css files to the /site/widgetcss/ folder.

	  3. In the /site/templates/ folder create a "head.tmpl" file if you haven't already.
	     In /site/templates/head.tmpl add the line:
		  <style> @import url(widgetcss/vlist.css); </style>

*/

// serve serves files from renderer folders.
func serve(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", 405)
		return
	}
	switch {
	case r.URL.Path == "/favicon.ico":
		withDefaultHeaders(w, r, serveFavIconPath)
	case r.URL.Path == "/":
		withDefaultHeaders(w, r, serveMain)
	case strings.HasPrefix(r.URL.Path, "/css"):
		withDefaultHeaders(w, r, serveURLPath)
	case strings.HasPrefix(r.URL.Path, "/wasm"):
		withDefaultWASMHeaders(w, r, serveWASMURLPath)
	default:
		http.Error(w, "Not found", 404)
	}
}

func withDefaultHeaders(w http.ResponseWriter, r *http.Request, fn http.HandlerFunc) {
	header := w.Header()
	header.Set("Cache-Control", "no-cache")
	fn(w, r)
}

func withDefaultWASMHeaders(w http.ResponseWriter, r *http.Request, fn http.HandlerFunc) {
	header := w.Header()
	header.Set("Cache-Control", "no-cache")
	header.Set("Content-Type", "application/wasm")
	fn(w, r)
}

func serveFavIconPath(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, filepaths.GetFaviconPath())
}

func serveMain(w http.ResponseWriter, r *http.Request) {
	// func serveMainHTML is in panelMap.go
	serveMainHTML(w)
}

func serveURLPath(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, filepaths.BuildRendererPath(r.URL.Path))
}

func serveWASMURLPath(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, filepaths.BuildRendererPath(r.URL.Path[5:]))
}

`

package templates

// SpawnTabPrepare is the tab's prepare.go template.
const SpawnTabPrepare = `{{$Dot := .}}package {{call .PackageNameCase .TabName}}

import ({{ range .PrepareImports }}
	"{{$Dot.ApplicationGitPath}}{{.}}"{{end}}
)

/*

	DO NOT EDIT THIS FILE.

	This file is generated by kickasm and regenerated by rekickasm.

*/

// Prepare initializes this package in preparation for spawning.
func Prepare(cl *lpc.Client, quitChan, eojChan chan struct{}, receiveChan lpc.Receiving, sendChan lpc.Sending, vtools *viewtools.Tools, njs *notjs.NotJS, help *paneling.Help) {
	client = cl
	tools = vtools
{{ range .PanelNames }}
	{{ call $Dot.PackageNameCase . }}.Prepare(quitChan, eojChan, receiveChan, sendChan, vtools, njs, help){{end}}
}
`

// SpawnTabSpawn is the tab's spawn.go template.
const SpawnTabSpawn = `{{$Dot := .}}package {{call .PackageNameCase .TabName}}

import (
	"fmt"
	"strings"
	"syscall/js"

	"github.com/pkg/errors"
{{ range .SpawnImports }}
	"{{$Dot.ApplicationGitPath}}{{.}}"{{end}}
)

/*

	DO NOT EDIT THIS FILE.

	This file is generated by kickasm and regenerated by rekickasm.

*/


const (
	tabBarID = "{{.TabBarID}}"
	tabName  = "{{.TabName}}"
)


var (
	markupTemplatePaths = {{.MarkupTemplatePaths}}
	// client is needed for client.IncReceivers() with spawns
	//   and client.DecReceivers() with unspawns.
	client *lpc.Client
	tools  *viewtools.Tools
)

// Tab represents a tab that will spawn and unspawn an html tab bar tab.
type Tab struct {
	uniqueID      uint64
	hTMLButton    js.Value
	stopListeners []func()
}

// Spawn creates the DOM elements and go code for a tab.
// This is called by the tab bar.
// Param tabLabel is the label in the tab button. The button's innerText.
// Param panelHeading is the heading for each panel.
// Param panelData is an empty interface passed to each panel's spawn func.
// Returns the tab unspawn func and the error.
func Spawn(tabLabel, panelHeading string, panelData interface{}) (unspawn func() error, err error) {

	defer func() {
		if err != nil {
			message := fmt.Sprintf("%s.Spawn()", "{{call .PackageNameCase .TabName}}")
			err = errors.WithMessage(err, message)
		}
	}()

	// Spawn the DOM elements.
	var tabButton js.Value
	var tabPanelHeader js.Value
	var uniqueID uint64
	var panelNameID map[string]string
	if tabButton, tabPanelHeader, uniqueID, panelNameID, err = tools.SpawnTab(tabBarID, tabName, tabLabel, panelHeading, markupTemplatePaths); err != nil {
		return
	}
	// Define the tab.
	tab := &Tab{
		hTMLButton :   tabButton,
		uniqueID :     uniqueID,
		stopListeners: make([]func(), 0, 20),
	}
	unspawn = tab.unSpawn
	// Build the go code.
	var f func()
{{ range .PanelNames }}
	if f, err = {{ call $Dot.PackageNameCase . }}.BuildPanel(uniqueID, tabButton, tabPanelHeader, panelNameID, panelData, unspawn); err != nil {
		return
	}
	tab.stopListeners = append(tab.stopListeners, f){{end}}
	client.IncReceivers(len(tab.stopListeners))
	return
}

// unSpawn totally removes the DOM elements and go code of a spawned tab.
// Returns the error.
func (tab *Tab) unSpawn() (err error) {

	defer func() {
		if err != nil {
			message := fmt.Sprintf("{{call .PackageNameCase .TabName}}.unSpawn(): uniqueID is %d", tab.uniqueID)
			err = errors.WithMessage(err, message)
		}
	}()

	client.DecReceivers(len(tab.stopListeners))

	messages := make([]string, 0, 2)
	// Remove the tab and panels from the DOM.
	if err = tools.UnSpawnTab(tab.hTMLButton); err != nil {
		messages = append(messages, err.Error())
	}
	// Unregister each panel controler's javascript call backs.
	if err = tools.UnRegisterCallBacks(tab.uniqueID); err != nil {
		messages = append(messages, err.Error())
	}
	// Stop each panel's caller's message listener.
	for _, stopListener := range tab.stopListeners {
		stopListener()
	}

	// construct a new error from the accumulated errors.
	if len(messages) > 0 {
		err = errors.New(strings.Join(messages, "\n"))
	}
	return
}

func (tab *Tab) Tab() js.Value {
	return tab.hTMLButton
}

func (tab *Tab) UniqueID() uint64 {
	return tab.uniqueID
}
`

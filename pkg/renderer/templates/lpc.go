package templates

// ChannelsGo is renderer/lpc/channels.go.
const ChannelsGo = `{{ $Dot := . }}// +build js, wasm

package lpc

import (
	"encoding/json"
	"fmt"
	"syscall/js"

	"github.com/pkg/errors"

	"{{.ApplicationGitPath}}{{.ImportDomainLPC}}"
	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
)

/*
	DO NOT EDIT THIS FILE.

	USE THE TOOL kicklpc TO ADD OR REMOVE LPC Messages.

	kicklpc will edit this file for you.

*/

// Sending is a channel that sends to the main process.
type Sending chan interface{}

// Receiving is a channel that receives from the main process.
type Receiving chan interface{}

var (
	send    Sending
	receive Receiving
	eoj     chan struct{}
	global  js.Value
	alert   js.Value
)

func init() {
	send = make(chan interface{}, 1024)
	receive = make(chan interface{}, 1024)
	eoj = make(chan struct{}, 1024)
	g := js.Global()
	global = g
	alert = g.Get("alert")
}

// Channels returns the renderer connection channels.
func Channels() (sendChan, receiveChan chan interface{}, eojChan chan struct{}) {
	sendChan = send
	receiveChan = receive
	eojChan = eoj
	return
}

// Payload converts unmarshalled msg to the correct marshalled payload.
func (sending Sending) Payload(msg interface{}) (payload []byte, err error) {

	defer func() {
		if err != nil {
			err = errors.WithMessage(err, "sending.Payload")
		}
	}()

	var bb []byte
	var id uint64
	switch msg := msg.(type) {
	case *message.LogRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 0
	case *message.InitRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 1{{ range $index, $name := .LPCNames }}
	case *message.{{ $name }}RendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = {{ call $Dot.Inc2 $index }}{{ end }}
	default:
		bb = []byte("Unknown!")
		id = 999
	}
	pl := &lpc.Payload{
		ID:    id,
		Cargo: bb,
	}
	payload, err = json.Marshal(pl)
	return
}

// Cargo returns a marshalled payload's unmarshalled cargo.
func (receiving Receiving) Cargo(payloadbb []byte) (cargo interface{}, err error) {

	defer func() {
		if err != nil {
			err = errors.WithMessage(err, "receiving.Cargo")
		}
	}()

	payload := lpc.Payload{}
	if err = json.Unmarshal(payloadbb, &payload); err != nil {
		return
	}
	switch payload.ID {
	case 0:
		msg := &message.LogMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 1:
		msg := &message.InitMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg{{ range $index, $name := .LPCNames }}
	case {{ call $Dot.Inc2 $index }}:
		msg := &message.{{ $name }}MainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg{{ end }}
	default:
		errMsg := fmt.Sprintf("no case found for payload id %d", payload.ID)
		err = errors.New(errMsg)
	}
	return
}
`

// ClientGo is renderer/lpc/client.go
const ClientGo = `// +build js, wasm

package lpc

import (
	"fmt"
	"log"
	"syscall/js"

	"github.com/pkg/errors"

	"{{.ApplicationGitPath}}{{.ImportDomainLPCMessage}}"
	"{{.ApplicationGitPath}}{{.ImportRendererCallBack}}"
	"{{.ApplicationGitPath}}{{.ImportRendererViewTools}}"
)

/*
	DO NOT EDIT THIS FILE.

	USE THE TOOL kicklpc TO ADD OR REMOVE LPC Messages.

	kicklpc will edit this file for you.

*/

// Client is a wasm local process communication client.
type Client struct {
	host           string
	port           uint64
	location       string
	connection     js.Value
	connected      bool
	dispatching    bool
	queue          [][]byte
	OnOpenCallBack func()

	SendChan    Sending
	ReceiveChan Receiving
	EOJChan     chan struct{}
	QuitCh      chan struct{}

	// OnOpenCallBack func()
	lpcing bool

	// handlers
	OnConnectionBreakJS js.Func
	OnConnectionBreak   func(this js.Value, args []js.Value) interface{}
}

// NewClient costructs a new Client.
func NewClient(host string, port uint64, quitCh chan struct{}, eojCh chan struct{}, receiving Receiving, sending Sending) *Client {
	v := &Client{
		host:     host,
		port:     port,
		location: fmt.Sprintf("ws://%s:%d/ws", host, port),
		queue:    make([][]byte, 0, 10),

		SendChan:    sending,
		ReceiveChan: receiving,
		EOJChan:     eojCh,
		QuitCh:      quitCh,
	}
	// Shut the renderer down when the connection breaks.
	v.SetOnConnectionBreak(
		func(event js.Value, args []js.Value) (nilReturn interface{}) {
			quitCh <- struct{}{}
			return
		},
	)
	return v
}

// SetOnConnectionBreak set the handler for the connection break.
func (client *Client) SetOnConnectionBreak(fn func(this js.Value, args []js.Value) interface{}) {
	client.OnConnectionBreak = fn
	client.OnConnectionBreakJS = callback.RegisterCallBack(fn)
}

// Connect connects to the server.
func (client *Client) Connect(callBack func()) (err error) {

	defer func() {
		if err != nil {
			err = errors.WithMessage(err, "client.Connect")
		}
	}()

	client.OnOpenCallBack = callBack
	if client.connected {
		log.Println("client is connected")
	}
	// setup the web socket
	ws := global.Get("WebSocket")
	client.connection = ws.New(client.location)
	if client.connection == js.Undefined() {
		err = errors.New("connection is undefined")
		return
	}
	rs := client.connection.Get("readyState")
	if rs.String() == "undefined" {
		err = errors.New("readystate is undefined")
		return
	}
	client.connection.Set("onopen", callback.RegisterCallBack(client.onOpen))
	client.connection.Set("onclose", callback.RegisterCallBack(client.onClose))
	client.connection.Set("onmessage", callback.RegisterCallBack(client.onMessage))
	return
}

func (client *Client) dispatch() {
	if client.dispatching {
		return
	}
	client.dispatching = len(client.queue) > 0
	for client.dispatching {
		payload := client.queue[0]
		client.queue = client.queue[1:]
		var cargo interface{}
		var err error
		if cargo, err = client.ReceiveChan.Cargo(payload); err != nil {
			alert.Invoke(err.Error())
			return
		}
		// Trap fatals from the main process and stop.
		switch msg := cargo.(type) {
		case *message.LogMainProcessToRenderer:
			if msg.Fatal {
				viewtools.GoModal(msg.ErrorMessage, "Fatal Error", client.onFatal)
				return
			}
		case *message.InitMainProcessToRenderer:
			if msg.Fatal {
				viewtools.GoModal(msg.ErrorMessage, "Fatal Error", client.onFatal)
				return
			}{{ range $index, $name := .LPCNames }}
		case *message.{{ $name }}MainProcessToRenderer:
			if msg.Fatal {
				viewtools.GoModal(msg.ErrorMessage, "Fatal Error", client.onFatal)
				return
			}{{ end }}
		}
		// No fatals so go on.
		panelsCount := viewtools.CountMarkupPanels()
		for i := 0; i < panelsCount; i++ {
			client.ReceiveChan <- cargo
		}
		client.dispatching = len(client.queue) > 0
	}
}

// Handlers.

func (client *Client) onFatal() {
    client.QuitCh <- struct{}{}
}

func (client *Client) onBreak(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.QuitCh <- struct{}{}
	return
}

func (client *Client) onOpen(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.connected = true
	log.Println("LPC has connected.")
	if client.lpcing {
		return
	}
	client.lpcing = true
	log.Println("starting LPC go routine.")
	go func() {
		for {
			select {
			case cargo := <-client.SendChan:
				log.Println("will send lpc cargo to main process")
				var payload []byte
				var err error
				if payload, err = client.SendChan.Payload(cargo); err != nil {
					log.Printf("sending.Payload(cargo) error is %s", err.Error())
				} else {
					log.Println("payload is " + string(payload))
					client.connection.Call("send", string(payload))
				}
			case <-client.QuitCh:
				// each markup panel has a messenger with a message dispatcher go routine.
				countWaiting := viewtools.CountMarkupPanels()
				// func main
				countWaiting++
				// widgets
				countWaiting += viewtools.CountWidgetsWaiting()
				eoj := struct{}{}
				for i := 0; i < countWaiting; i++ {
					client.EOJChan <- eoj
				}
				client.lpcing = false
				return
			}
		}
	}()
	client.OnOpenCallBack()
	return
}

func (client *Client) onClose(this js.Value, args []js.Value) (nilReturn interface{}) {
	client.connected = false
	log.Println("LPC has disconnected.")
	client.OnConnectionBreak(js.Undefined(), nil)
	return
}

func (client *Client) onMessage(this js.Value, args []js.Value) (nilReturn interface{}) {
	e := args[0]
	data := e.Get("data").String()
	client.queue = append(client.queue, []byte(data))
	client.dispatch()
	return
}
`
